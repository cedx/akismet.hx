<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace akismet;

use \php\_Boot\HxAnon;
use \php\Boot;
use \sys\Http;
use \tink\_Url\Url_Impl_;
use \thenshim\_Promise\Promise_Impl_;
use \thenshim\Thenable;
use \haxe\io\Path;

/**
 * Submits comments to the [Akismet](https://akismet.com) service.
 */
class Client {
	/**
	 * @var string
	 * The Akismet API key.
	 */
	public $apiKey;
	/**
	 * @var Blog
	 * The front page or home URL of the instance making requests.
	 */
	public $blog;
	/**
	 * @var string
	 * The URL of the API end point.
	 */
	public $endPoint;
	/**
	 * @var bool
	 * Value indicating whether the client operates in test mode.
	 */
	public $isTest;
	/**
	 * @var string
	 * The user agent string to use when making requests.
	 */
	public $userAgent;

	/**
	 * Creates a new client.
	 * 
	 * @param string $apiKey
	 * @param Blog $blog
	 * @param mixed $options
	 * 
	 * @return void
	 */
	public function __construct ($apiKey, $blog, $options = null) {
		$this->userAgent = "Haxe/" . "4.1.4" . "-" . "php" . " | Akismet/" . "1.0.0";
		$this->isTest = false;
		$this->endPoint = "https://rest.akismet.com/1.1";
		$this->apiKey = $apiKey;
		$this->blog = $blog;
		if ($options !== null) {
			if (isset($options["endPoint"])) {
				$this->endPoint = Path::removeTrailingSlashes($options["endPoint"]);
			}
			if (isset($options["isTest"])) {
				$this->isTest = $options["isTest"];
			}
			if (isset($options["userAgent"])) {
				$this->userAgent = $options["userAgent"];
			}
		}
	}

	/**
	 * Checks the specified `comment` against the service database, and returns a value indicating whether it is spam.
	 * 
	 * @param Comment $comment
	 * 
	 * @return Thenable
	 */
	public function checkComment ($comment) {
		$url = Url_Impl_::fromString($this->endPoint);
		$tmp = ($url->hosts->arr[0] ?? null);
		return Promise_Impl_::then($this->fetch("" . ($url->scheme??'null') . "://" . ($this->apiKey??'null') . "." . ((($tmp === null ? "null" : $tmp))??'null') . ((($url->path === null ? "null" : $url->path))??'null') . "/comment-check", $comment->toJson()), function ($response) {
			if ($response->body === "false") {
				return 0;
			} else if (($response->headers->data["X-akismet-pro-tip"] ?? null) === "discard") {
				return 2;
			} else {
				return 1;
			}
		});
	}

	/**
	 * Queries the service by posting the specified fields to a given end point, and returns the response as a string.
	 * 
	 * @param string $endPoint
	 * @param mixed $fields
	 * 
	 * @return Thenable
	 */
	public function fetch ($endPoint, $fields) {
		$body = $this->blog->toJson();
		$_g_keys = \Reflect::fields($fields);
		$_g_index = 0;
		while ($_g_index < $_g_keys->length) {
			$key = ($_g_keys->arr[$_g_index++] ?? null);
			$_g = new HxAnon([
				"value" => \Reflect::field($fields, $key),
				"key" => $key,
			]);
			\Reflect::setField($body, $_g->key, $_g->value);
		}
		if ($this->isTest) {
			\Reflect::setField($body, "is_test", "1");
		}
		$http = new Http($endPoint);
		$http->setHeader("Content-Type", "application/x-www-form-urlencoded");
		$http->setHeader("User-Agent", $this->userAgent);
		$http1 = $http;
		$_g = new \Array_hx();
		$_g1_keys = \Reflect::fields($body);
		$_g1_index = 0;
		while ($_g1_index < $_g1_keys->length) {
			$key = ($_g1_keys->arr[$_g1_index++] ?? null);
			$_g1 = new HxAnon([
				"value" => \Reflect::field($body, $key),
				"key" => $key,
			]);
			$value = $_g1->value;
			$x = "" . (\rawurlencode($_g1->key)??'null') . "=" . (\rawurlencode($value)??'null');
			$_g->arr[$_g->length++] = $x;
		}
		$http1->setPostData($_g->join("&"));
		return Promise_Impl_::_new(function ($resolve, $reject) use (&$http) {
			$http->onData = function ($data) use (&$reject, &$resolve, &$http) {
				if (\array_key_exists("X-akismet-debug-help", $http->responseHeaders->data)) {
					$reject1 = $reject;
					$value = ($http->responseHeaders->data["X-akismet-debug-help"] ?? null);
					$reject1(new ClientException($value, $http->url));
				} else {
					$resolve(new HxAnon([
						"body" => $data,
						"headers" => $http->responseHeaders,
					]));
				}
			};
			$http->onError = function ($error) use (&$reject, &$http) {
				$reject(new ClientException($error, $http->url));
			};
			$http->request(true);
		});
	}

	/**
	 * Submits the specified `comment` that was incorrectly marked as spam but should not have been.
	 * 
	 * @param Comment $comment
	 * 
	 * @return Thenable
	 */
	public function submitHam ($comment) {
		$url = Url_Impl_::fromString($this->endPoint);
		$tmp = ($url->hosts->arr[0] ?? null);
		return $this->fetch("" . ($url->scheme??'null') . "://" . ($this->apiKey??'null') . "." . ((($tmp === null ? "null" : $tmp))??'null') . ((($url->path === null ? "null" : $url->path))??'null') . "/submit-ham", $comment->toJson());
	}

	/**
	 * Submits the specified `comment` that was not marked as spam but should have been.
	 * 
	 * @param Comment $comment
	 * 
	 * @return Thenable
	 */
	public function submitSpam ($comment) {
		$url = Url_Impl_::fromString($this->endPoint);
		$tmp = ($url->hosts->arr[0] ?? null);
		return $this->fetch("" . ($url->scheme??'null') . "://" . ($this->apiKey??'null') . "." . ((($tmp === null ? "null" : $tmp))??'null') . ((($url->path === null ? "null" : $url->path))??'null') . "/submit-spam", $comment->toJson());
	}

	/**
	 * Checks the API key against the service database, and returns a value indicating whether it is valid.
	 * 
	 * @return Thenable
	 */
	public function verifyKey () {
		return Promise_Impl_::then($this->fetch("" . ($this->endPoint??'null') . "/verify-key", new HxAnon(["key" => $this->apiKey])), function ($response) {
			return $response->body === "valid";
		});
	}
}

Boot::registerClass(Client::class, 'akismet.Client');
